package com.bluebell.processing.processors;

import com.bluebell.platform.models.api.json.StandardJsonResponse;
import com.bluebell.platform.util.DirectoryUtil;
import com.bluebell.processing.enums.DependencyType;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.squareup.javapoet.FieldSpec;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.StringUtils;

import javax.lang.model.element.Modifier;
import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

/**
 * Parent-level processor for re-usable functionality
 *
 * @author Stephen Prizio
 * @version 0.1.0
 */
@Slf4j
public abstract class AbstractBluebellProcessor implements BluebellProcessor {

    /**
     * Identifies the root path for the location of generated source files
     *
     * @return path as a string
     */
    String getGeneratedSourcePath() {
        return Paths.get(
                DirectoryUtil.getBaseProjectDirectory().replace(File.separator + "greenhouse", StringUtils.EMPTY),
                "greenhouse",
                "processing",
                "target", "generated-sources", "annotations"
        ).toAbsolutePath().normalize().toString();
    }

    /**
     * Generates a global public static final field
     *
     * @param fieldName name of field
     * @param json json data
     * @return {@link FieldSpec}
     * @throws JsonProcessingException error when processing json into a string
     */
    FieldSpec generateGlobalStaticField(final String fieldName, final StandardJsonResponse<?> json) throws JsonProcessingException {
        return
                FieldSpec
                        .builder(String.class, fieldName)
                        .addModifiers(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL)
                        .initializer("$S", new ObjectMapper().writeValueAsString(json))
                        .build();
    }

    /**
     * Updates the module-info.java file with the correct dependencies
     *
     * @param dependencyType {@link DependencyType}
     * @param packageName package name
     * @throws IOException file reading / writing error
     */
    void updateModuleInfo(final DependencyType dependencyType, final String packageName) throws IOException {

        Path moduleInfoPath = Paths.get(
                DirectoryUtil.getBaseProjectDirectory().replace(File.separator + "greenhouse", StringUtils.EMPTY),
                "greenhouse",
                "processing",
                "src", "main", "java",
                "module-info.java"
        );

        if (!Files.exists(moduleInfoPath)) {
            throw new IOException("module-info.java does not exist");
        }

        final String code = String.format("\t%s %s;", dependencyType.getCodeSyntax(), packageName);
        final String comment = String.format("\t//\tauto-generated by %s", this.getClass().getSimpleName());

        LOGGER.info("Cleaning module-info.java before code generation...");

        final List<String> lines =
                Files.readAllLines(moduleInfoPath)
                        .stream()
                        .filter(line -> !line.equals(code))
                        .filter(line -> !line.equals(comment))
                        .collect(Collectors.toCollection(ArrayList::new));

        LOGGER.info("Updating dependencies in module-info.java...");

        lines.add(1, code);
        lines.add(1, comment);
        Files.write(moduleInfoPath, lines);

        LOGGER.info("Dependencies successfully updated.");
    }
}
